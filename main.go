package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"unicode"

	"cloud.google.com/go/spanner/spansql"
	"github.com/rinchsan/gosimports"
	"golang.org/x/sync/errgroup"
)

func main() {
	var src, dst string

	flag.StringVar(&src, "src", "./db/spanner/migrations/", "where are the migration files stored")
	flag.StringVar(&dst, "dst", "./tables/", "where to store the table structures")

	flag.Parse()

	tables, err := LoadMigrations(src)
	if err != nil {
		panic(err)
	}

	files, err := CreateFileData(tables)
	if err != nil {
		panic(err)
	}

	err = WriteFiles(dst, files)
	if err != nil {
		panic(err)
	}
}

type Table struct {
	*spansql.CreateTable
	indexes []*spansql.CreateIndex
}

func LoadMigrations(dir string) (map[spansql.ID]*Table, error) {
	files, err := os.ReadDir(dir)
	if err != nil {
		return nil, fmt.Errorf("reading %q: %w", dir, err)
	}

	tables := map[spansql.ID]*Table{}
	indexes := map[spansql.ID]*spansql.CreateIndex{}

	for _, f := range files {
		if f.IsDir() {
			continue
		}

		fileName := f.Name()
		file, err := os.ReadFile(filepath.Join(dir, fileName))
		if err != nil {
			continue
		}

		statements, err := spansql.ParseDDL(fileName, string(file))
		if err != nil {
			continue
		}

		for _, stmt := range statements.List {
			switch stmt := stmt.(type) {
			case *spansql.CreateTable:
				tables[stmt.Name] = &Table{CreateTable: stmt}
			case *spansql.CreateIndex:
				indexes[stmt.Name] = stmt
				tables[stmt.Table].indexes = append(tables[stmt.Table].indexes, stmt)
			case *spansql.DropTable:
				delete(tables, stmt.Name)
			case *spansql.DropIndex:
				table := indexes[stmt.Name].Table
				delete(indexes, stmt.Name)

				tables[table].indexes = filter(
					tables[table].indexes,
					func(index *spansql.CreateIndex) bool {
						return index.Name != stmt.Name
					},
				)
			case *spansql.AlterIndex:
				switch alter := stmt.Alteration.(type) {
				case spansql.AddStoredColumn:
					indexes[stmt.Name].Storing = append(indexes[stmt.Name].Storing, alter.Name)
				case spansql.DropStoredColumn:
					indexes[stmt.Name].Storing = filter(
						indexes[stmt.Name].Storing,
						func(col spansql.ID) bool {
							return col != alter.Name
						},
					)
				}
			case *spansql.AlterTable:
				switch alter := stmt.Alteration.(type) {
				case spansql.AddColumn:
					tables[stmt.Name].Columns = append(tables[stmt.Name].Columns, alter.Def)
				case spansql.DropColumn:
					tables[stmt.Name].Columns = filter(
						tables[stmt.Name].Columns,
						func(col spansql.ColumnDef) bool {
							return col.Name != alter.Name
						},
					)
				case spansql.AlterColumn:
					switch c := alter.Alteration.(type) {
					case spansql.SetColumnType:
						for _, col := range tables[stmt.Name].Columns {
							if col.Name == alter.Name {
								col.Type, col.NotNull, col.Default = c.Type, c.NotNull, c.Default
								break
							}
						}
					}
				}
			}
		}
	}

	return tables, nil
}

func CreateFileData(tables map[spansql.ID]*Table) (map[string][]byte, error) {
	files := make(map[string][]byte, len(tables)+1)
	files["tables.go"] = mainFile()

	var buf bytes.Buffer
	for _, table := range tables {
		snakelike := camelToSnakeCase(string(table.Name))
		fileName := snakelike + ".go"
		if _, exist := files[fileName]; exist {
			for i := 2; true; i++ {
				fileName = snakelike + strconv.Itoa(i) + ".go"
				if _, exist = files[fileName]; !exist {
					break
				}
			}
		}

		buf.Reset()
		generate(&buf, table)

		b := append([]byte{}, buf.Bytes()...)
		b, err := gosimports.Process(fileName, b, nil)
		if err != nil {
			return files, fmt.Errorf("formatting %q: %w", fileName, err)
		}

		files[fileName] = b
	}

	return files, nil
}

func mainFile() []byte {
	return []byte(`// Code generated by tablegen. DO NOT EDIT.
package tables

func Get() AllTables                   { return AllTables{} }
func WithAlias(alias string) AllTables { return AllTables{alias: alias} }

type AllTables struct{ alias string }

type Index struct {
	tableAlias, tableName, indexName string
	columns                      []string
}

func (i Index) Name() string             { return i.indexName }
func (i Index) Table() string            { return i.tableName }
func (i Index) AllColumnNames() []string { return i.columns }
func (i Index) ForcedTable() string      { return tableName(i.tableName, i.indexName, i.tableAlias) }

func tableName(table, index, alias string) string {
	if index != "" {
		table += "@{force_index=" + index + "}"
	}
	if alias != "" {
		table += " AS " + alias
	}
	return table
}

func colName(alias, col string) string {
	if alias == "" {
		return col
	}
	return alias + "." + col
}
`)
}

func generate(buf *bytes.Buffer, table *Table) {
	tableName := string(table.Name)
	tableType := string(table.Name) // TODO: Cast to camelCase and check that the type is not already taken.

	sort.Slice(table.Columns, func(i, j int) bool {
		return less(table.Columns[i].Name, table.Columns[j].Name)
	})

	buf.WriteString(
		`// Code generated by tablegen. DO NOT EDIT.
package tables

func (t AllTables) ` + tableType + `() ` + tableType + `{ return ` + tableType + `(t) }

type ` + tableType + ` struct { alias string }

func (t ` + tableType + `) TableAlias() string { return t.alias }
func (t ` + tableType + `) name() string { return "` + tableName + `" }
func (t ` + tableType + `) TableName() string { return tableName(t.name(), "", t.alias) }`)

	// TODO: Cast to camelCase and check that the type is not already taken.
	tableColsType := string(table.Name) + "Cols"

	buf.WriteString(`
func (t ` + tableType + ` ) AllColumnNames() []string {
	c := t.Columns()
	return []string{`)
	for _, col := range table.Columns {
		fieldName := string(col.Name)
		buf.WriteString(`
		c.` + fieldName + `(),`)
	}
	buf.WriteString(`
	}
}

func (t ` + tableType + `) Columns() ` + tableColsType + ` { return ` + tableColsType + `{tableAlias: t.alias} }

type ` + tableColsType + ` struct { tableAlias string }
`)
	for _, col := range table.Columns {
		colName := string(col.Name)
		fieldName := string(col.Name)
		buf.WriteString(`
func (c ` + tableColsType + `) ` + fieldName + `() string { return colName(c.tableAlias, "` + colName + `") }`)
		writeColComment(buf, col)
	}

	buf.WriteByte('\n')

	if len(table.indexes) == 0 {
		return
	}

	// TODO: Cast to camelCase and check that the type is not already taken.
	tableIndexesType := string(table.Name) + "Indexes"
	buf.WriteString(`
func (t ` + tableType + `) Indexes() ` + tableIndexesType + `{ return ` + tableIndexesType + `{table: t} }

type ` + tableIndexesType + ` struct { table ` + tableType + ` }
`)

	sort.Slice(table.indexes, func(i, j int) bool {
		a, b := table.indexes[i], table.indexes[j]
		return len(a.Columns) < len(b.Columns) || (len(a.Columns) == len(b.Columns) && less(a.Name, b.Name))
	})

	indexNames := make(map[string]struct{}, len(table.indexes))

	for _, index := range table.indexes {
		indexName := string(index.Name)
		fieldName := "By"
		for _, key := range index.Columns {
			fieldName += string(key.Column)
			if key.Desc {
				fieldName += "Desc"
			}
		}
		if _, exist := indexNames[fieldName]; exist {
			for i := 2; true; i++ {
				if _, exist = indexNames[fieldName+strconv.Itoa(i)]; !exist {
					fieldName += strconv.Itoa(i)
					break
				}
			}
		}
		indexNames[fieldName] = struct{}{}

		cols := make([]spansql.ID, 0, len(table.PrimaryKey)+len(index.Columns)+len(index.Storing))
		cols = append(cols, index.Storing...)
		for _, key := range table.PrimaryKey {
			cols = append(cols, key.Column)
		}
		for _, col := range index.Columns {
			cols = append(cols, col.Column)
		}

		sort.Slice(cols, func(i, j int) bool { return less(cols[i], cols[j]) })

		buf.WriteString(`
func (i ` + tableIndexesType + `) ` + fieldName + `() Index {
	c := i.table.Columns()
	return Index{
		tableAlias: i.table.alias,
		tableName:  i.table.name(),
		indexName:  "` + indexName + `",
		columns: []string{`)
		for _, col := range cols {
			field := string(col)
			buf.WriteString(`
			c.` + field + `(),`)
		}
		buf.WriteString(`
		},
	}
}
`)
	}
}

func writeColComment(buf *bytes.Buffer, col spansql.ColumnDef) {
	buf.WriteString(`// ` + col.Type.SQL())
	if !col.NotNull {
		buf.WriteString(" NULL")
	}
	if col.Default != nil {
		buf.WriteString(" DEFAULT (" + col.Default.SQL() + ")")
	}
	if col.Generated != nil {
		buf.WriteString(" AS (" + col.Generated.SQL() + ") STORED")
	}
	if col.Options != (spansql.ColumnOptions{}) {
		buf.WriteString(" " + col.Options.SQL())
	}
}

func WriteFiles(dst string, files map[string][]byte) error {
	err := os.RemoveAll(dst)
	if err != nil {
		return fmt.Errorf("removing %q: %w", dst, err)
	}

	err = os.MkdirAll(dst, 0750)
	if err != nil {
		return fmt.Errorf("creating %q: %w", dst, err)
	}

	var g errgroup.Group
	g.SetLimit(20)

	for fileName, data := range files {
		fileName, data := fileName, data
		g.Go(func() error {
			return writeFile(filepath.Join(dst, fileName), data)
		})
	}

	return g.Wait()
}

func writeFile(fileName string, data []byte) error {
	file, err := os.Create(fileName)
	if err != nil {
		return fmt.Errorf("creating %q: %w", fileName, err)
	}

	defer file.Close()

	_, err = file.Write(data)
	if err != nil {
		return fmt.Errorf("writing to %q: %w", fileName, err)
	}
	return nil
}

func less(a, b spansql.ID) bool { return len(a) < len(b) || (len(a) == len(b) && a < b) }

func camelToSnakeCase(s string) string {
	var buf bytes.Buffer
	r := strings.NewReader(s)
	for {
		r, _, err := r.ReadRune()
		if errors.Is(err, io.EOF) {
			return buf.String()
		}

		if unicode.IsUpper(r) && buf.Len() > 0 {
			buf.WriteByte('_')
		}

		buf.WriteRune(unicode.ToLower(r))
	}
}

func filter[T any](s []T, cond func(T) bool) []T {
	var n int
	for _, v := range s {
		if cond(v) {
			s[n], n = v, n+1
		}
	}
	return s[:n]
}
